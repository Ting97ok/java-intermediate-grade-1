## Object 클래스
### 묵시적 상속
- 모든 클래스는 명시적 상속이 없으면 Object 클래스를 묵시적으로 상속받는다.

### toString() 메서드 실행 순서 (내가 맞았슴 ㅋ)
1. 본인 타입인 클래스에서 `toString()`을 찾고 없으면 부모 타입 클래스에서 찾는다.

### Object 클래스가 최상위 부모 클래스인 이유
#### 공통 기능 제공
- 모든 클래스가 공통으로 사용하는 기능을 제공한다.
- `toString()`: 객체 정보 제공
- `equals()`: 객체의 동등 비교
- `getClass()`: 객체의 클래스 정보 제공

#### 다형성의 기본 구현
- 부모는 자식을 담을 수 있다.
- `Object` 타입으로 모든 객체를 담을 수 있다.

## Object 다형성
### Object 다형성의 장점
- Object를 매개변수로 사용하면 어떤 객체든지 인자로 전달할 수 있다.

### Object 다형성의 한계
- Object는 최종 부모이므로 더는 올라가서 찾을 수 없어서 자식 객체의 메타데이터를 사용할 수 없다.
- Object를 통해 전달받은 객체의 본래 타입의 메타데이터(메서드, 필드 등)를 사용하려면 원래 타입으로 다운캐스팅을 해야 한다.
- 다형성을 활용하려면 다형적 참조 + 메서드 오버라이딩을 활용해야 하지만 Object는 오버라이딩이 불가능하다.
    - `다형성`: 여러 가지 형태를 가질 수 있는 능력
    - `다형적 참조`: 부모 클래스 타입의 변수가 자식 클래스의 객체를 참조할 수 있는 것
    - `메서드 오버라이딩`: 부모 클래스의 메서드를 자식 클래스에서 재정의하는 것
    #### 개인적인 의견
    - Object 뿐만 아니라 부모 클래스로서의 역할인 경우 모든 클래스가 오버라이딩은 불가능하다.
    - Object만의 한계가 아니라고 느껴진다.
    - 애초에 단일 클래스로써 다형성을 구현하는 것이 아니라 부모 클래스는 다형적 참조의 역할을 자식 클래스는 메서드 오버라이딩의 역할을 함으로써 다형성이 유지된다고 생각한다.

### Object가 없다면?
- 모든 객체를 인자로 받을 수 있는 메서드를 만들 수 없다.
- 모든 객체를 담을 수 있는 컬렉션이나 배열을 만들 수 없다.

## toString() 메서드
### toString() 오버라이딩
- `toString()` 메서드는 기본 구현이 참조값과 클래스명을 반환한다.
- 기본 구현 정보로는 객체의 정보를 알기 어렵다.
- `toString()` 메서드를 오버라이딩하여 객체의 정보를 반환하도록 재정의하는 것이 일반적이다.

### 다른 타입의 객체를 Object 타입에 담았을 때 toString() 호출 플로우
- `Object` 타입에 담긴 객체에 `toString()`을 호출하면 해당 참조 주소에 저장된 Object와 본래 타입의 데이터를 확인한다.
- 본래 타입 데이터에 `toString()`이 오버라이딩 되어 있는지 확인한다.
- 오버라이딩 되어 있으면 해당 메서드를 실행한다.
- 오버라이딩 되어 있지 않으면 Object의 `toString()`을 실행한다.
#### 개인적인 의견
- 해당 부분은 설명이 부족하다고 생각한다.
- 상단에 적은 내용도 강의 자료 그림을 보면서 어느정도 유추한 내용이다.
- 강의 자료에도 `자식에 재정의(오버라이딩)된 메서드가 있는지 찾아본다.`라고 명시되어 있는데 Object가 최상위 부모인데 무슨 소리를 하는지 모르겠다.
- 실제 객체의 타입이 Car여도 Dog에 오버라이딩된 toString()이 있다면 Dog의 toString()이 실행된다는 설명같이 보인다.
- 근데 실제 동작은 그게 아니잖아

## equals() - 1. 동일성과 동등성
- **동일성**: 두 객체의 참조가 동일한 객체를 가리키고 있는지 확인
- **동등성**: 두 객체가 논리적으로 동등한지 확인
- 내가 이해한 예시
  - 1번째로 찍어낸 제품과 1억번째로 찍어낸 제품이 있다.
  - 콜렉터는 이 두 제품은 같지 않다고 느낄 것 (동일성)
  - 일반인은 이 두 제품은 같다고 느낄 것 (동등성)
  - 1번째로 찍어낸 제품의 가치를 모르는 `그게 뭔데 씹덕아`인 일반인 입장에서 비교하는게 동등성
  - 1번째로 찍어낸 제품의 가치를 아는 씹덕 입장에서 비교하는게 동일성
  - 나는 `메모리 주소가 뭔데 씹덕아`인 일반인 이니까 생긴게 똑같으면 같다고 판단한다.
  - 컴퓨터는 메모리 주소가 뭔지 아는 씹덕 이니까 다르다고 판단한다.
  - 그래서 equals()를 오버라이딩해서 내가 정의한 기준으로 동등성을 판단한다.

### equals() 메서드를 구현할 때 지켜야 하는 규칙
- **반사성(Reflexivity)**: 객체는 자기 자신과 동등해야 한다. (`x.equals(x)` 는 항상 `true` ).
- **대칭성(Symmetry)**: 두 객체가 서로에 대해 동일하다고 판단하면, 이는 양방향으로 동일해야 한다. (`x.equals(y)` 가 `true` 이면 `y.equals(x)`도`true` ).
- **추이성(Transitivity)**: 만약 한 객체가 두 번째 객체와 동일하고, 두 번째 객체가 세 번째 객체와 동일하다면, 첫 번째 객체는 세 번째 객체와도 동일해야 한다.
- **일관성(Consistency)**: 두 객체의 상태가 변경되지 않는 한, `equals()` 메소드는 항상 동일한 값을 반환해야 한다.
- **null에 대한 비교**: 모든 객체는 `null` 과 비교했을 때 `false` 를 반환해야 한다.