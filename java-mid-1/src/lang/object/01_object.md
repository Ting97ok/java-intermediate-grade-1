# 1. Object

- Object 클래스는 모든 클래스의 최상위 부모 클래스이다.
    - Object 클래스는 묵시적으로 모든 클래스에 상속된다. → 즉 명시적으로 선언된 부모 클래스가 없다면 Object클래스가 부모 클래스인 것.
    - 명시적으로 다른 클래스를 상속 받는다면 자바에서 Object 클래스를 상속해주지 않음.
    - Parent라는 클래스와 Parent 클래스를 상속받는 Child 라는 클래스가 있다면 Child는 Object 클래스를 상속받지 않고 Parent는 Object 클래스를 상속받는다.
    - Child에서 Object 클래스의 메서드를 호출하면 Child → Parent → Object 순서로 해당 메서드를 찾고 호출한다.

- Object가 최상위 부모 클래스인 이유
    - 공통 기능 제공
        - 객체의 정보를 제공하고 해당 객체가 다른 객체와 다른지 비교하고 또한 어떤 클래스로 만들어졌는지 확인하는 기능은 모든 객체에게 필요한 기본 기능이다. 원래라면 위와 같은 기능을 항상 새로운 메서드를 정의해서 만들어야 한다.
        - 위의 메서드를 만들더라도 개발자마다 메서드 명을 다르게 정의할 확률이 높다.
        - Object 클래스에서 toString(), equals(), getClass() 와 같은 메서드로 정의 해준다. → 이러한 상황을 개발자들은 알고 있기 때문에 프로그래밍이 단순화되고 일관성을 가짐.
            - toString() : 객체의 정보 제공
            - equals() : 객체의 같음을 비교
            - getClass() : 객체의 클래스 정보를 제공
    - 다형성의 기본 구현
        - Object는 모든 클래스의 부모 클래스이기 때문에 모든 객체를 참조 할 수 있다.
        - 즉 모든 자바 객체는 Object 타입으로 처리될 수 있기 때문에 타입이 다른 객체를 어딘가에 보관해야 한다면 Object에 보관하면 된다.

- Object의 다형성
    - Object는 모든 타입의 부모이므로 모든 객체를 담을 수 있다.
    - 그러나 A라고 하는 새로 만든 클래스의 B라고 하는 새로 만든 메서드 는 Object에서 모르기 때문에 호출이 불가능하다. → Object에는 없는 메서드이므로 오버라이딩도 불가능
    - 즉 Object에서 A 클래스의 B 메서드를 호출하기 위해서는 instanceof 를 이용한 다운 캐스팅을 해야 호출이 가능하다. → 모든 클래스는 부모의 메서드를 호출할 수 있지만 자식의 메서드는 호출이 불가능하기 때문

- Object 배열
    - Object는 모든 타입의 객체를 받을 수 있다. 즉 Object 배열을 만들면 모든 객체를 담을 수 있는 배열을 만들 수 있다.
    - 메서드를 생성할 때 변수로 Object배열을 받는다면 배열 안에 어떤 객체가 있더라도 해당 메서드를 모든 프로젝트에서도 사용이 가능하다.
    - Object가 없다면 직접 클래스를 생성 후 모든 클래스에서 직접 정의한 해당 클래스를 상속하면 위와 같은 배열이 가능하겠지만 프로젝트를 생성할 때마다 해당 작업을 해야하고 서로 호환되지 않은 메서드들이 넘쳐날 것이다.

- toString()
    - toString() 메서드는 객체의 정보를 문자열 형태로 제공한다.
    - 이 메서드는 Object 클래스에 정의되어있으므로 모든 클래스에서 상속받아 활용이 가능하다.
    - 이 메서드는 기본적으로 패키지를 포함한 객체의 이름과 객체의 참조값을 16진수로 제공한다.
    - println()과 toString()은 출력된 값이 동일한데 그 이유는 println() 내부에서 toString()을 호출하기 때문이다.
    - toString() 메서드는 클래스 정보와 참조값을 제공하지만 객체의 상태를 적절히 나타내지 않기 때문에 오버라이딩을 통해 사용자가 원하는 정보를 표출 할 수 있다. → 오버라이딩을 하면 부모 클래스보다 자식 클래스의 오버라이딩 된 메서드가 우선순위를 가지기 때문

- Object와 OCP
    - Object가 없다면 공통의 부모가 없는 객체의 정보를 출력하기 어려움 → 그러므로 새로운 클래스를 만들어 객체를 정의하거나 각각의 클래스마다 출력하기 위한 별도의 메서드를 작성해야함.
    - Object는 각각의 클래스처럼 구체적인 클래스가 아닌 추상적인 클래스이다. 즉 모든 Object를 의존하는 클래스를 생성한다면 모든 객체에서 해당 클래스를 호출할 수 있다.
    - 이러한 것은 OCP 원칙을 잘 지켜준다.
        - Open : 새로운 클래스를 추가하고 toString() 등을 오버라이딩 해서 기능을 확장 할 수 있음.
        - Closed : 새로운 클래스를 추가하더라도 Object를 활용한 기존의 클래스를 변경 할 필요가 없음.

- equals()
    - 동일성 : == 연산자 사용 , 두 객체의 참조가 동일한 객체인지 확인
    - 동등성 : .equals() 메서드 사용 , 두 객체가 논리적으로 동일한지 확인
    - Object에서 .equals()는 == 로 동일성 비교를 제공 → 동등성 비교는 각각의 클래스마다 다르고 이걸 Object에서 알수 없기 때문
    - 즉 동등성 비교를 사용하려면 equals()를 오버라이딩 해야함.
        - 대부분 IDE 에서 만들어줌..
        - 동등성 비교가 항상 필요한 것은 아니므로 꼭 필요한 경우에만 재정의 하면 됨